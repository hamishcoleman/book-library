#!/usr/bin/perl
use warnings;
use strict;
#
# Given an ISBN, look it up
#

our $VERSION=1;

use Getopt::Long 2.33 qw(:config gnu_getopt);
use Pod::Usage;

use FileHandle;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;

use XML::LibXML;

use Term::ReadLine;


# FIXME - globals
$term = new Term::ReadLine 'getisbndb';
my $parser = XML::LibXML->new();
my $db={};

###############################################################################
##
## Standard options processor
sub do_options(%@) {
	my $option = shift;
	GetOptions($option,@_) or pod2usage(2);
	pod2usage(-exitstatus => 0, -verbose => 2) if $option->{man};

	if ($option->{quiet}) {
		delete $option->{verbose};
	}
}

###############################################################################

my $option={};          # set option defaults here
$option->{verbose}=0;
$option->{key}='CHANGEME';
# remember to update the SYNOPSIS and OPTIONS when this changes
do_options($option,
		"man",
		"verbose|v+",
		"quiet|q",
		"key=s",
		"isbn=s",
		"xml=s",
		"stdin",
		"log=s",
		"db=s",
);

#
# Generic http dumping routine
#
sub dump_res($$) {
	my ($desc, $res) = @_;

	if (!$res->is_success) {
		print "DUMP RES: $desc\n";
		print "Status:", $res->status_line, "\n";
		print Dumper($res);
		warn "!is_success";
	}

	if ($option->{verbose}>1) {
		print "DUMP RES: $desc\n";
		print Dumper($res);
	}
}

#
# Setup the LWP useragent
#
sub http_setup() {
	use LWP::UserAgent;
	use HTTP::Cookies;
	my $ua = LWP::UserAgent->new;
	$ua->agent("Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.3) Gecko/20070310");
	$ua->cookie_jar(HTTP::Cookies->new());

	# LWP talks about RFC 2616 when it says that POST's cannot redirect
	# I have looked up the standard and it does not appear to say that
	#
	# FIXME - find out why LWP wants this in the face of the above comment
	push @{ $ua->requests_redirectable }, 'POST';

	return $ua;
}

sub isbn_xml($) {
	my ($text) = @_;
	my $res;

	my $doc = $parser->parse_string($text);
	if (!$doc) {
		warn "Not a valid XML document";
		return;
	}
	my $root = $doc->getDocumentElement();

	return $root;
}

#
# Make an isbndb.com query and return the XML result data
#
sub isbn_get($$$) {
	my ($ua,$key,$isbn) = @_;

	my $url = "http://isbndb.com/api/books.xml?access_key=$key&results=details,texts,prices,authors,keystats&index1=isbn&value1=$isbn";

	addlog('GET ',$url,"\n");
	my $req = HTTP::Request->new(GET => $url);
	my $res = $ua->request($req);
	dump_res('get',$res);

	if (!$res->is_success) {
		return;
	}
	addlog($res->content,"\n");
	$db->{_}{isbn_get}=$res->content;

	return isbn_xml($res->content);
}

sub isbn_xml2text($) {
	my ($root) = @_;
	my $res;

	for my $node ($root->getElementsByTagName('BookData')) {
		$res.=$node->getAttribute('isbn')."\t";
		for my $title ($node->getElementsByTagName('Title')) {
			$res.=$title->textContent().", ";
		}
		for my $title ($node->getElementsByTagName('AuthorsText')) {
			$res.=$title->textContent().", ";
		}
		$res.="\n";
	}

	return $res;
}

# <KeyStats granted="22" access_key="CHANGEME" requests="22" limit="500" />
sub update_keystats($) {
	my ($root) = @_;

	for my $node ($root->getElementsByTagName('KeyStats')) {
		$db->{_}{KeyStats}{granted} = $node->getAttribute('granted');
		$db->{_}{KeyStats}{requests} = $node->getAttribute('requests');
		$db->{_}{KeyStats}{limit} = $node->getAttribute('limit');
	}
}

sub addlog {
	if (!$option->{log}) {
		return;
	}
	if (!$option->{logfh}) {
		$option->{logfh} = new FileHandle $option->{log},"a";
		if (!defined $option->{logfh}) {
			die "could not open $option->{log} $!\n";
		}
	}
	$option->{logfh}->print(@_);
}

sub db_index_bookdata($) {
	my ($node) = @_;

	$db->{book_id}{$node->getAttribute('book_id')} = $node;
	$db->{isbn}{$node->getAttribute('isbn')} = $node;
}

sub db_load($) {
	my ($filename) = @_;

	my $fh = new FileHandle $filename,"r";
	if (!defined $fh) {
		die "could not open $filename $!\n";
	}
	$db->{_}{doc} = $parser->parse_fh($fh);
	# TODO - warn / create an empty document on fail
	$db->{_}{isbndb} = $db->{_}{doc}->getDocumentElement();

	for my $node ($db->{_}{doc}->getElementsByTagName('BookData')) {
		db_index_bookdata($node);
	}
}

sub db_save() {
	my $fh = new FileHandle $option->{db}.'.new','w';
	if (!defined $fh) {
		die "could not open $option->{db}.new $!\n";
	}
	$db->{_}{doc}->toFH($fh,1);
}

sub db_new_fake_isbn() {
	my $i = $db->{_}{last_fake_isbn} || 1;

	my $isbn = sprintf("Z%08iZ",$i);
	while(defined($db->{isbn}{$isbn})) {
		$i++;
		$isbn = sprintf("Z%08iZ",$i);
	}
	$db->{_}{last_fake_isbn} = $i;
	return $isbn;
}

sub adddb {
	if (!$option->{db}) {
		return;
	}

	my ($root) = @_;
	for my $node ($root->getElementsByTagName('BookData')) {
		$db->{_}{isbndb}->appendChild($node);
		db_index_bookdata($node);
	}

	# paranoid write
	db_save();
}

sub not_found_bookdata($$) {
	my ($isbn,$text) = @_;

	my $root = XML::LibXML::Element->new('ISBNdb');
	my $node = XML::LibXML::Element->new('BookData');
	$root->appendChild($node);
	$node->setAttribute('book_id','unkid'.$isbn);
	$node->setAttribute('isbn',$isbn);
	$node->appendTextChild('Title',$text);
	$node->appendTextChild('AuthorsText','UNKNOWN');
	$node->appendTextChild('Summary','');
	$node->appendTextChild('Details','');
	$node->appendTextChild('Prices','');
	$node->appendTextChild('Authors','');

	return $root;
}

sub do_prev($$) {
	my ($cmd,$args) = @_;

	$db->{_}{not_found} = $args;
}

sub do_ls($$) {
	my ($cmd,$args) = @_;

	if (!$option->{db}) {
		return;
	}

	print isbn_xml2text($db->{_}{isbndb});
}

sub do_eval($$) {
	my ($cmd,$str) = @_;

	print eval $str;
	print "\n";
}

sub do_history($$) {
	my ($cmd,$str) = @_;

	print join("\n",$term->GetHistory());
}

sub do_fake($$) {
	my ($cmd,$str) = @_;

	do_prev($cmd,db_new_fake_isbn());
}

sub process_one_bookdata($$) {
	my ($search,$root) = @_;

	my $text = isbn_xml2text($root);
	if (!defined $text) {
		$text = "NOT FOUND\n";
		$db->{_}{not_found} = $_;
	}
	print $text;
	addlog("T $search\t$text");
	adddb($root);
	update_keystats($root);
}

sub do_one_cmdline($$) {
	my ($ua) = shift;
	chomp;

	# ISBN's start with numbers
	if ($_ =~ m/^[0-9]/) {
		# TODO - split input at first non digit
		# TODO - check the isbn check-digit
		print "$_\t";
		my $root = isbn_get($ua,$option->{key},$_);
		if ($root) {
			process_one_bookdata($_,$root);
		} else {
			print "ERROR: getting isbn details\n";
			# TODO: check if it is a EAN13 but not bookland
			# and ask the user to type in an ISBN
		}
		return;
	}

	# cmdline
	if ($_ =~ m/^:(\w+) ?(.*)/) {
		# TODO more structure for this hash, including helptext
		my %cmds = (
			prev => \&do_prev,
			ls => \&do_ls,
			e => \&do_eval,
			history => \&do_history,
			fake => \&do_fake,
		);

		if ($cmds{$1}) {
			$cmds{$1}($1,$2);
		} else {
			print "Invalid command.  Use one of:\n";
			print "\t",join(' ',sort keys %cmds),"\n";
		}
		return;
	}

	# some kind of manual text entry
	addlog("GET MANUAL\n");	# a record separator
	if ($_ && $db->{_}{not_found}) {
		my $root = not_found_bookdata($db->{_}{not_found},$_);
		process_one_bookdata($db->{_}{not_found},$root);
	}
	addlog("M $_\n");
	delete $db->{_}{not_found};
}

sub do_repl($) {
	my ($ua) = @_;

	$term->ornaments(0);
	my $attribs = $term->Attribs;
	$attribs->{completion_entry_function} =
		$attribs->{list_completion_function};
	# FIXME - calculate this list from the cmdline hash table
	$attribs->{completion_word} =
		[qw(:e :ls :prev :history :fake)];

	my $prompt = "> ";
	while ( defined ($_ = $term->readline($prompt)) ) {
		do_one_cmdline($ua,$_);
		#$term->addhistory($_) if /\S/;

		$prompt = "";
		if ($db->{_}{KeyStats}{granted}) {
			$prompt .= 'G:'.$db->{_}{KeyStats}{granted}.' ';
		}
		if ($db->{_}{not_found}) {
			$prompt .= 'P:'.$db->{_}{not_found}.' ';
		}
		$prompt .= '> ';
	}
}

if ( !defined($option->{key})){
	die "must specify access key";
}

if ($option->{db}) {
	db_load($option->{db});
}

my $ua = http_setup();

if ($option->{xml}) {
	my $xml = $option->{xml};
	addlog("GET from string\n");	# a record separator
	addlog($xml,"\n");

	my $root = isbn_xml($xml);
	if ($root) {
		process_one_bookdata('xml',$root);
	} else {
		print "ERROR: getting isbn details\n";
	}
	print "G:",$db->{_}{KeyStats}{granted};
	print "\n";

} elsif ($option->{stdin}) {
	do_repl($ua);
} elsif ($option->{isbn}) {
	my $root = isbn_get($ua,$option->{key},$option->{isbn});
	if ($root) {
		process_one_bookdata($option->{isbn},$root);
	} else {
		print "ERROR: getting isbn details\n";
	}
	print "G:",$db->{_}{KeyStats}{granted};
	print "\n";
} else {
	die "Must specify isbn";
}

if ($option->{db}) {
	rename($option->{db},$option->{db}.'.old');
	rename($option->{db}.'.new',$option->{db});
}

__END__
